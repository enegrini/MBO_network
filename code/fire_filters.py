# -*- coding: utf-8 -*-
"""Fire_Filters.ipynb

Automatically generated by Colab.

"""
# Import necessary libraries
import os
import cv2
import numpy as np
from google.colab import drive
from matplotlib import pyplot as plt

# Mount Google Drive
drive.mount('/content/drive')

# Define the path to the folder containing the images - replace with your own directory
image_folder_path = ''
output_folder_path = ''

# Ensure the output directory exists
os.makedirs(output_folder_path, exist_ok=True)

# Define the anchor point for the 500x500 square
anchor_x, anchor_y = 400, 0  # Adjust this according to your needs

# Define Gaussian filter parameters
gaussian_blur_ksize = (15, 15)
gaussian_blur_sigma = 5

# Define the threshold value
threshold_value = 127

# Initialize a list to store the inverted images for video creation
inverted_images = []

# Function to process each image and display results
def process_image(image_path):
    print(f"Processing image: {image_path}")

    # Load the image
    image = cv2.imread(image_path)

    # Check if the image is loaded
    if image is None:
        print(f"Failed to load image: {image_path}")
        return

    # Crop the image to 500x500 starting from the anchor point
    cropped_image = image[anchor_y:anchor_y + 500, anchor_x:anchor_x + 500]

    # Apply Gaussian filter to blur the image
    blurred_image = cv2.GaussianBlur(cropped_image, gaussian_blur_ksize, gaussian_blur_sigma)

    # Convert to HSV to isolate the red areas
    hsv_image = cv2.cvtColor(blurred_image, cv2.COLOR_BGR2HSV)

    # Define range for red color and create a mask
    lower_red1 = np.array([0, 70, 50])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([170, 70, 50])
    upper_red2 = np.array([180, 255, 255])

    mask1 = cv2.inRange(hsv_image, lower_red1, upper_red1)
    mask2 = cv2.inRange(hsv_image, lower_red2, upper_red2)
    red_mask = cv2.bitwise_or(mask1, mask2)

    # Create an image with red areas as black and non-red areas as white
    red_areas_image = np.zeros_like(cropped_image)
    red_areas_image[red_mask == 0] = [255, 255, 255]  # Set non-red areas to white
    red_areas_image[red_mask != 0] = [0, 0, 0]  # Set red areas to black

    # Convert to grayscale
    gray_image = cv2.cvtColor(red_areas_image, cv2.COLOR_BGR2GRAY)

    # Threshold the image
    _, thresholded_image = cv2.threshold(gray_image, threshold_value, 255, cv2.THRESH_BINARY)

    # Invert the image
    inverted_image = cv2.bitwise_not(thresholded_image)

    # Append the inverted image to the list for video creation
    inverted_images.append(inverted_image)

    # Save the inverted image
    base_name = os.path.basename(image_path)
    name, ext = os.path.splitext(base_name)
    new_name = f"{name}_inverted{ext}"
    output_image_path = os.path.join(output_folder_path, new_name)
    cv2.imwrite(output_image_path, inverted_image)

    # Save the inverted image as .npy file
    npy_output_path = os.path.join(output_folder_path, f"{name}_inverted.npy")
    np.save(npy_output_path, inverted_image)

    # Display the results
    plt.figure(figsize=(20, 10))

    plt.subplot(1, 6, 1)
    plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
    plt.title('Cropped Image')

    plt.subplot(1, 6, 2)
    plt.imshow(cv2.cvtColor(blurred_image, cv2.COLOR_BGR2RGB))
    plt.title('Blurred Image')

    plt.subplot(1, 6, 3)
    plt.imshow(cv2.cvtColor(hsv_image, cv2.COLOR_HSV2RGB))
    plt.title('HSV Image')

    plt.subplot(1, 6, 4)
    plt.imshow(cv2.cvtColor(red_areas_image, cv2.COLOR_BGR2RGB))
    plt.title('Red Areas Image')

    plt.subplot(1, 6, 5)
    plt.imshow(thresholded_image, cmap='gray')
    plt.title('Thresholded Image')

    plt.subplot(1, 6, 6)
    plt.imshow(inverted_image, cmap='gray')
    plt.title('Inverted Image')

    plt.show()

# Process all images in the folder in name order
image_filenames = sorted([f for f in os.listdir(image_folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg'))])

for image_filename in image_filenames:
    image_path = os.path.join(image_folder_path, image_filename)
    process_image(image_path)

print("Processing complete.")

# Create a video from the inverted images
output_video_path = os.path.join(output_folder_path, 'output_video.avi')
frame_height, frame_width = inverted_images[0].shape
fourcc = cv2.VideoWriter_fourcc(*'XVID')
video_writer = cv2.VideoWriter(output_video_path, fourcc, 1, (frame_width, frame_height), False)

for image in inverted_images:
    video_writer.write(image)

video_writer.release()

print(f"Video saved at {output_video_path}")

"""2nd version - used for fire set2 remains"""

# Import libraries
import os
import cv2
import numpy as np
from google.colab import drive
from matplotlib import pyplot as plt

# Mount Google Drive
drive.mount('/content/drive')

# Define the path to the folder containing the images - replace with your own directory
image_folder_path = ''
output_folder_path = ''

# Ensure the output directories exist
os.makedirs(output_folder_path, exist_ok=True)
bw_output_folder = os.path.join(output_folder_path, 'bw_outputs')
os.makedirs(bw_output_folder, exist_ok=True)

# Define the anchor point for the 500x500 square
anchor_x, anchor_y = 450, 100  # Adjust this according to your needs

# Define Gaussian filter parameters
gaussian_blur_ksize = (15, 15)
gaussian_blur_sigma = 5

# Define the threshold value for binary thresholding
threshold_value = 127  # You can adjust this value as needed

# Define the threshold value for contour size filtering
contour_size_threshold = 300  # You can adjust this threshold according to your needs

# Function to process each image and display results
def process_image(image_path):
    print(f"Processing image: {image_path}")

    # Load the image
    image = cv2.imread(image_path)

    # Check if the image is loaded
    if image is None:
        print(f"Failed to load image: {image_path}")
        return

    # Crop the image to 500x500 starting from the anchor point
    cropped_image = image[anchor_y:anchor_y + 100, anchor_x:anchor_x + 100]

    # Save the cropped image
    cropped_image_path = os.path.join(output_folder_path, os.path.basename(image_path))
    cv2.imwrite(cropped_image_path, cropped_image)

    # Apply Gaussian filter to blur the image
    blurred_image = cv2.GaussianBlur(cropped_image, gaussian_blur_ksize, gaussian_blur_sigma)

    # Convert to HSV to isolate the red areas
    hsv_image = cv2.cvtColor(blurred_image, cv2.COLOR_BGR2HSV)

    # Define range for red color and create a mask
    lower_red1 = np.array([0, 70, 50])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([170, 70, 50])
    upper_red2 = np.array([180, 255, 255])

    mask1 = cv2.inRange(hsv_image, lower_red1, upper_red1)
    mask2 = cv2.inRange(hsv_image, lower_red2, upper_red2)
    red_mask = cv2.bitwise_or(mask1, mask2)

    # Create an image with red areas as black and non-red areas as white
    red_areas_image = np.zeros_like(cropped_image)
    red_areas_image[red_mask == 0] = [255, 255, 255]  # Set non-red areas to white
    red_areas_image[red_mask != 0] = [0, 0, 0]  # Set red areas to black

    # Convert to grayscale
    gray_image = cv2.cvtColor(red_areas_image, cv2.COLOR_BGR2GRAY)

    # Threshold the image
    _, thresholded_image = cv2.threshold(gray_image, threshold_value, 255, cv2.THRESH_BINARY)

    # Invert the image
    inverted_image = cv2.bitwise_not(thresholded_image)

    # Detect and delete contours that are smaller than the specified threshold
    contours, _ = cv2.findContours(inverted_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        if cv2.contourArea(contour) < contour_size_threshold:
            cv2.drawContours(inverted_image, [contour], -1, (0, 0, 0), thickness=cv2.FILLED)

    # Save the final black & white (inverted) image in the bw_output_folder
    base_name = os.path.basename(image_path)
    name, ext = os.path.splitext(base_name)
    bw_image_name = f"{name}_inverted{ext}"
    bw_image_path = os.path.join(bw_output_folder, bw_image_name)
    cv2.imwrite(bw_image_path, inverted_image)

    # Display the results
    plt.figure(figsize=(20, 10))

    plt.subplot(1, 6, 1)
    plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
    plt.title('Cropped Image')

    plt.subplot(1, 6, 2)
    plt.imshow(cv2.cvtColor(blurred_image, cv2.COLOR_BGR2RGB))
    plt.title('Blurred Image')

    plt.subplot(1, 6, 3)
    plt.imshow(cv2.cvtColor(hsv_image, cv2.COLOR_HSV2RGB))
    plt.title('HSV Image')

    plt.subplot(1, 6, 4)
    plt.imshow(cv2.cvtColor(red_areas_image, cv2.COLOR_BGR2RGB))
    plt.title('Red Areas Image')

    plt.subplot(1, 6, 5)
    plt.imshow(thresholded_image, cmap='gray')
    plt.title('Thresholded Image')

    plt.subplot(1, 6, 6)
    plt.imshow(inverted_image, cmap='gray')
    plt.title('Inverted Image')

    plt.show()

# Process all images in the folder in name order
image_filenames = sorted([f for f in os.listdir(image_folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg'))])

for image_filename in image_filenames:
    image_path = os.path.join(image_folder_path, image_filename)
    process_image(image_path)

print("Image processing complete.")

# Save video
from google.colab import drive
drive.mount('/content/drive')

import cv2
import os
import numpy as np

# Path to the output folder where the black & white images are stored - replace with your own directory
bw_output_folder = ''

# Get a sorted list of all black & white images
image_filenames = sorted([f for f in os.listdir(bw_output_folder) if f.lower().endswith(('.png', '.jpg', '.jpeg'))])

# Ensure there are images in the folder
if len(image_filenames) > 0:
    # Get the first image to determine the size
    first_image_path = os.path.join(bw_output_folder, image_filenames[0])
    first_image = cv2.imread(first_image_path, cv2.IMREAD_GRAYSCALE)
    height, width = first_image.shape

    # Create a video writer object
    output_video_path = os.path.join(bw_output_folder, 'output_video.avi')
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, 1, (width, height), False)

    # Read each image and add it to the video
    for image_filename in image_filenames:
        image_path = os.path.join(bw_output_folder, image_filename)
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        video_writer.write(image)

    video_writer.release()
    print(f"Video saved at {output_video_path}")

    # Save the video as a .npy file
    video_frames = [cv2.imread(os.path.join(bw_output_folder, img), cv2.IMREAD_GRAYSCALE) for img in image_filenames]
    video_npy_path = os.path.join(bw_output_folder, 'output_video.npy')
    np.save(video_npy_path, np.array(video_frames))
    print(f"Video saved as .npy file at {video_npy_path}")
else:
    print("No images found in the specified folder.")

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Install moviepy
!pip install moviepy

from moviepy.editor import VideoFileClip

# Define the path to the input and output video files - replace with your own directory
input_video_path = ''
output_video_path = ''

# Define the start and end times for trimming (in seconds)
start_time = 1  # start at 10 seconds
end_time = 11    # end at 30 seconds

# Load the video clip
video = VideoFileClip(input_video_path)

# Trim the video clip
trimmed_video = video.subclip(start_time, end_time)

# Write the trimmed video to a file
trimmed_video.write_videofile(output_video_path, codec='libx264')

print(f"Trimmed video saved at {output_video_path}")
